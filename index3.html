<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title> first project</title>
</head>
<body>
    <h1>backtracking</h1>
    <h2>backtracking is a form of reacursion.</h2>
    <p>The usual scenario is that you are faced with a number of optins,and you must choose one of these. after you make your <br>
     choice you will get a new set of options; just what set of options you get depends on what choices, you made. This  procedure is <br>
     repeated over and over until you reach a final state.if you made a good sequence of choices, your final state is a goal state;if <br>
     you didn't,it isn'at. </p> 

    
    <p>coceptually, you start at the root of a tree, the tree probably has some good leaves and some bad leaves, though it may be that <br>
    the leaves are all good or all bad. you want to get to good leaf. At each node, beginnning eith the root, you choose one of its <br>
     children to move to, and you keep this up until you get to a leaf.</p>
     
    <p>suppose you get to a bad leaf. you can backtrak to continue the searh for a good leaf by reviking your most recent choice <br>
    and trying out the next optin in that set of optins.if you run out of option, revoke the choice that got you here, and try <br>
     another chocice at that node. if you and up at the root with no option left, there are no good leaves to be found.</p>

     <p>This needs an example.</p>
      
     <img src="./image.root.png" alt="not showing" width="300" height="200">
      
     <ol >
        <li>starting at root, your options are A and B. you choosoose A</li>

        <br>

        <li>At A, your options are C and D. you choose C.</li>

        <br>

        <li>C is bad. go back to A.</li>

        <br>

        <li>At A, you have alraedy tried C, and it failed.try D.</li>

        <br>

        <li>D is bad. Go back to A</li>

        <br>

        <li>At A, you have no options left to try.go back to Root.</li>

        <br>

        <li>At Root, you have already tried a. try B.</li>
        
        <br>

        <li>At B, your option are E and F. try E</li>

        <br>

        <li>E is good congratulations!</li>
     </ol>
     <fieldset>
        in this exalmle we drew a picture of a tree. is an abstract model of the possible sequence of choice we cloud

        <br>

       make. There is also data structure called a tree, but usually we don't have a data structure to tell uss what choices
        
       <br>
       
       we have.(if we do have an actual tree data structure, backtracking on it is called depth-first tree search
      </fieldset>
     <h3>The backtracking algorithm.</h3>
     <br>
       &nbsp;
       
     <pre>
      <font color="blue">
     <p> boolean solve(Node n) {
      <br>
         if n is a leaf node {
           <br>

       if the leaf is a goal node,return true 
       <br>
        else return false
        <br>
           } else { 
            <br>
         for each child c of n {
            <br>
            if solve(c) succeeds, return true 
            <br>
         }
         return false 
           
            }
         } </font>
      </pre> 
      
      &nbsp;
     <fieldset>
      notice that the algorithm is expressed as a boolean function. this is essential to understanding the algorithm. if 
      <br>
       solve(n) is true, that means node n is part of a solution--that is, node n is one of the nodes on a path from the root to <br>
       some goal node. we say that n is solvable. if solve(n) is false, then there is no path that includes n to any goal node.
     </fieldset>
     
       <h3>how does this work?</h3>  
       <ul>
      
         <li>if any childof n is solvable, then n is solvable.</li>
         <li>if no child of n is solvable, then n is not solvable.</li>
         
       </ul> 
       <p>Hence, to decide wherher any non-leaf node n is solvable (part of a path to a goal node), all you have to do is test whether any <br> 
      child of n is solvable. this is done recursively, on each of n. in the above code of n. in the above code, this is done by the lines </p>
        
      
      <pre>
        <font color="blue"> 
         for each child c of n { 
            <br>
           if solve(c) succeeds, return true 
           <br>
         } 
          return false 
      </pre>
       </font>
      <p>eventually the recursion will "bottom" out at a leaf node is a goal node, it is solvable; if the leaf node is not a goal <br>
         node, it is not solvable. this is our base case. in the above code, this is done by the lines </p>
         
         <br>
         <br>
   
         <pre>
            <font color="blue">
            
            if n is a leaf node {
               <br>
               
            if the leaf is a goal node, return true 
            <br>
         
             else return false 
             <br>
             
             }

            </font>
            </pre>
         
         <p>the backtraking algorithm is simple but important. you should understandand it thorougly. another way of starting it is as follows;:</p>
         <ul>
             <li> <h3>To search a tree</h3></li>
         </ul>
         <ol type="1">
            <li>if the tree consists of a single leaf, test whether it is a goal node.</li>
            <li>otherwise. search the subtrees until you find one containing a goal node, or until you have searched them all unsuccessfully.</li>
         
            <h3>Non- recursive backtraking, uding a stack</h3>
            <p>backtraking is a rather typical recursive  algorithm, and any recursive algorithm can be rewritten as a stack algorithm in fact.
               <br>
               that is how your recursive algorithm are transtated info machine or assembly language.</p>
              
             <pre>
             <font color="blue">
            boolean solve(node n) {
               <br>
             put node n on the stack;
             <br>
             while the stack is not empty {
               <br>
               if the node at the top of the stack is a leaf {
                  <br>
                  if it is a goal node,return true
                  <br>
                  else pop it off the stack 
                  <br>  
            }
            <br>
            else {
               <br>if the node at the top of the stack has untried children 
               <br>
               push the next untried child onto the stack 
               <br>
               else pop the node off the  stack
               <br>
                   }
                   return false 
                  }
             </font>
             </pre> 
              <h3>keeping backtraacking simple</h3>
               
              <p>all off these version of the backtracking algorithm are pretty simple, but when applied to a real problem, they can get pretty 
               
               <br>
                 cluttered up with details. evendeteming whether the node is a leaf can be complex: </p>
                 <br>
                 <p>for example, if the path repesent a series of moves in a chess endgame problem, the leaves are the checkmate and statmete <br>
                  solution 
                 </p>
               
                 <p>to keep the prpgram clean, therefor, tests like this should be buried in a chess game, for example, you could test 
                  <br>
                  whether a node is a leaf by writing a <b>gameover method</b>(or you could even call it <strong>isleaf</strong>).this method would encapsulate all the 
                  <br>
                  ugly details of figuring out whether any possible moves remain.
                 </p>
                  
                 <p>
                  notice that the backtraking algorithm requir us to keep track, for each node on the current path, which of its children have <br>
                  been treid already (so we don't have to try them again). in the above code we made this look simple, by just saying <b>for each child <br>c of n. </b>
                   in reality, it may be diffult to figure out what the possible children are, and there may be no obvious way to step throigh <br> 
                  them in class, for example, a node can represent one arrangemment of the pices on a chessboard, and each child of that node can <br>
                  represent the arrangment after some piece has made legal move. how do you find these children, and how do you keep track <br>
                  of which ones you've already examined?</p>
                  <br>
                  <br>

                  <p>the most straightforward way to keep track of which chidren of the node have been tried is as follow. upon initial   entry to the <br>
                     node (that is, when you first get there from above), make a list of all its chidren. as you try each child, take it off the list. when <br>
                     the list is, empty, there are no remaining untried chidren, and return "failure."
                     this is a simple approach, but it may require <br>
                     quite a lot of additonal work.</p>
                     <p>thre is an easiar way to keep track of which children, ahve been tried, if you can define an ordering on the children. if there is an <br>
                     odering, and you know which child you just treid, you can determine ehichch child to try next.</p>
                     <br>
  
                  <p>ordering, and you know which childh you can determine which child to try next.</p>
                  <br>
                  <br>
                   <p>for example, you might be able to number the <strong>children 1 through n,</strong> and try them in numerical  order. then, if you have just tried <br> 
                    <b>child k,</b> you know that you have already treid children 1 through <b>k-1</b> and you have not yet treid children <b>k+1</b> through <b>n.</b> or, if you <br>
                    are trying to color a map with just four color, you can always try <b>red first, then yellow, then green, then blue.</b> if child yellow falls, <br>
                    you know to try child green next. if you are searching a maze, you can try choices in the order left, straight, right (<b>or perhaps north, east, south,west).</b></p>

                    <p>it isn't always easy to find a simple way to order the children of a node. <b>In the chess game example,</b>you might number your <br>
                     pieces (or perhaps the squares of the board) and try them in numerical order, but in addition each piece may also have several <br>
                      moves, and these must also be ordered.</p>
                      <br>
                      <br>
                    <font color="blue">
                     <pre>
                       boolean explore2(int row, int column, int color) {
                        if (row >=NUM_ROWS)return true;
                     if (okToColor[row,column,color]) { 
                        map[row][column] = color;
                        for (int nextcolor =RED;nextcolor <= BLUE; nextcolor++) {
                           int[]next = nexrowandcolumn(row,column);
                           if (explore2(next[0],next[1],nextcolor)) return true;

                        }
                       }
                       return false;
                     }
                     </pre>
                    </font>
                    <br><br>
                    <p>those appear pretty similar,and you might think they are equally good. However,the timing information suggests otherwise;</p>
                    <br>
                    <table border="1"  align="center">
                     <tr>
                        <td width="25%"> &nbsp; </td>
                        <td bgcolor="gray">2 by 3 map</td>
                        <td bgcolor="gray">>3 by 3 map</td>
                        <td bgcolor="gray">>3 by 4 map</td>
                     </tr>
                     <td bgcolor="gray">method 1:</td>
                     <td > 60 ms.</td>
                     <td >940 ms.</td>
                     <td>60530 ms. (1 minute)</td>
                     <tr>
                        <td bgcolor="gray">method 2:</td>
                        <td>0ms.</td>
                        <td>0ms.</td>
                        <td>0ms.</td>

                     </tr>

                     </tr>
                    

                    </table>
                    <br>
                    <br>
                    <p>the zeros in the above table indicate times  too short to measure (less than 1 millisecond). why this huge diffrance? either of <br>
                  these methods could have exponetial growth. eliminating a node automatically eliminates all of its descendents, and this will <br>
                  often prent exponetial growth. conversely, by waitin to check until a leaf node is reached, exponetial growthis  practically
                  guaranteed if there is any way to eliminate children (reduce the set of choices).do so! </p>
                  <br>
                  <hr>
                  <br>
                  <h3>Debuging techniques</h3>
                  <p>often our first try at a program doesn't work,and we need to debug it. Debuguggers are helpful, but sometimes we need to fall <br>
                     back on inserting print statement there are some simple trick to making efecktive use of print statements. these trick can be <br>
                     applied to any program, but are especially usefull when you are trying to debug recursive routines.</p>
                     <br><br>
                     <h4>trick#1: Indent when you print method entries and exits.</h4>
                     <br>
                     <p>often, the best Debuging techniques is to print every method call and return (or at least the most important ones).you  probably <br>
                        want to print, for  each method, what parameters it came in with, value it leaves with However, if you just print a long <br>
                         list of these, it's hard to match up method exist with thier corresponding entries. to show the level of nesting can help. <br>
                        </p>
                        <br>
                        <h4>trick #2: use specialized print methods for Debuging.</h4>
                        <br>
                        <p> don't clutter up your actual code more than you must Also, remeber that code inserted for Debuging purpose can itself <br>
                          contain bugs, or ( in the worst case) can affect the result, so be very careful with it. </p>
                          <br>
                          <br>
                          <p>here's our Debugging code. for this trivial program, there's almost more Debugging code than actual code, but in larger programs <br>
                        the proportion will be better.</p>
                        <br>
                        <font color="blue">
                           <pre>
                              static String indent = "";

                              static String name(binarytree node) {
                                 if (node == null) return null;
                                 else return node.name;
                              }
                               
                              static void enter(binarytree node) {
                                 System.out.printin(indent + "Entering solvable ("+ name(node)+")");
                                 indent = indent +"|";
                              }

                              static boolean yes(binarytree node){
                                 indent =indent.substring(#);
                                 System.out.printin(indent + "solvable("+ name(node) +")return true");
                                 return true;

                              }
                              
                              static boolean no(binarytree node) {
                                 indent = indent.substring(3);
                                 System.out.printin(indent +"solvable(" + name(node)+")return false");
                                 return false;
                              }
                           </pre>
                        </font>
                        <br>
                        <br>
                        <p>to use thise code, we modify solvable as follows;</p>
                        <br>
                        <br> 
                        <font color="blue">
                           <pre>
                              static boolean solvable(binarytree node) {
                                 enter(node);
                                 if (node.isGoalNode) return no(node);
                                 if (solvable(node.leftchild)) return yes(node);
                                 if (solvable(node.rightchild)) return yes(node);
                                 return no(node);
                              }
                           </pre>
                        </font>
                        <p>And we get these results: <br>
                           <p>Entering solvable(Root) <br> <br>
                              | Entering solvable(A) <br> <br>
                              || Entering solvable(c) <br> <br>
                              ||| Entering solvable(null) <br> <br>
                              ||| solvable(null) return false <br> <br>
                              ||| Entering solvable(null) <br> <br>
                              ||| solvable(null)return false <br> <br>
                              || solvable(C) return false <br> <br>
                              || Entering solvable(D) <br> <br>
                              ||| Entering solvable(null) <br> <br>
                              ||| solvable(null) return false <br> <br>
                              ||| Entering solvable(null) <br>  <br>
                              ||| solvable(null) return false <br> <br>
                              || solvable(D) return false <br> <br>
                              | solvable(A) return false <br> <br>
                              | Entering solvable(B) <br> <br>
                              || Entering solvable(E) <br> <br>
                              || solvable(E) return true <br> <br>
                              | solvable(D) return true <br> <br>
                              | solvable(Root) return true <br> <br>
                              true  </p>
                              <br>
                              <br> 
                              <b>trick#3: Never discard your Debugging statement.</b>
                              <br>
                              <br>
                              <p>writing Debugging statement is programming too. often it's as much work to debug the Debugging statement as it to debu <br>
                              the actua program. once your program is working, why throw this code away?</p>
                              <br>
                              <br>
                              obvious, you don't want to print out all this debugging information  from a program you are ready to submit (or to turn over to <br>
                              your manager). you could comment out your debugging clalls, but that can be a lot of work. what's more, in the example, <br>
                              you would have to replace every return(yes(node)) eith return(true), and evey return false. with all these <br>
                              changes, you might itroduce new bugs into your program.
                              <br><br>
                              <p>the simple solution is to make  your debugging statement conditional. for example,</p>
                              <br>
                              <font color="blue">
                                 <pre>
                                  static final boolean debugging = false;

                                  static void enter(binarytree node) {

                                  if  (debugging) { 

                                    System.out.printin + "Entering solvable("+ name(node) +")");
                                 
                                     indent = indent + "|";
                                    }
                                 }

                                 static boolean yes(binarytree node) {

                                    if (debugging){

                                    indent = indent.subsring(3);
                                    System.out.printin(indent + "solvable("+ name(node) + ")return true"); 
                                 }
                                 return

                              }

                              static boolean no(binarytree node) {
                                 if (debugging) {
                                    indent = indent.substring(3;)
                                    System.out.printin(indent + "solvable(" + name(node) +") return false");

                                 }
                                return false;
                              }
                                 </pre>
                              </font>
                              <br>
                              <p> in industry, actual programs often have multiple flags to control diffrent aspects of debugging don't worry too much about <br>
                                 making your code larger modern compliers will notice that since the variable debugging is final, it can never be true, and the <br> 
                                 controlied code will be discarded.
                              </p>
                                  <br> 
                                  <br>
                                  <b>trick#4: creat an exception.</b>
                                  <br>
                                  <p>if an exception is thrown, you can get information about just where it happened by sending it the massage <br>
                                      printStacktrace(printstream). since an exception is an object like any other, you can create and throw your own exception. <br>
                                      However, jaba programmers don't always realize that you can creat an exception whithout throwing it. For example, the following <br>
                                      code.</p>
                                      <br>
                      <font color="blue">
                                   <pre>
                                     new exception("Checkpoint charlie").printStacktrace(System.out);
                                  </pre>
                            </font>
                            <br>
                            <br>
                            <p>will print out a massage something like this, and the program will then continue normally. That is, the above code just acts like a <br>
                           print statment.</p>
                           <br><br>
                           <font color="blue">
                              <pre>
                                 java.lang.Exception: Checkpoint charlie
                                 at Treesearch.solvable(Treesearch.java:53)
                                 at Treesearch.solvable(Treesearch.java:57)
                                 at Treesearch.main(Treesearch.java:72)
                                 at_SHELL38.run(at_SHELL38.java:16)
                                 at bluej.runtime.Execserver.suspendExecution(Unknown Source) 
                              </pre> 
                           </font>
                           <br>
                           
                           <hr>
                           <br>
                           <h3>example: Cindy's Puzzle</h3>
                           <p>I call the following Puzzle "Cindy Puzzle" for historical reasions. you have some number n of black marbles and the same number <br>
                              of  white marbles, and you have a playing board which consists simply of a line of 2n+1 spaces to put the marbles in. Start with <br>
                              the black marbles all at  one end  (say,the left), the white marbles all at the other end, and a free space in between.
                            </p>
                            <br>
                            <table border="1" align="center">
                              
                              <tr>
                                 
                                 <td bgcolor="grey" width="10%" align="center"><img src="./black ball.png" alt=""></td>
                                 <td bgcolor="grey" width="10%" align="center"><img src="./black ball.png" alt=""></td>
                                 <td bgcolor="grey" width="10%" align="center">&nbsp;</td>
                                 <td bgcolor="grey" width="10%" align="center"><img src="./white ball.png" alt=""></td>
                                 <td bgcolor="grey" width="10%" align="center"><img src="./white ball.png" alt=""></td>
                              </tr>
                            </table>
                            <br>
                            <p>the goal is to reverse the position of the marbles:</p>
                            <br>
                            <table border="1" align="center">
                              <tr>  
                                 <td bgcolor="grey" width="10%" align="center"><img src="./white ball.png" alt=""></td>
                                 <td bgcolor="grey" width="10%" align="center"><img src="./white ball.png" alt=""></td>
                                 <td bgcolor="grey" width="10%" align="center">&nbsp;</td>
                                 <td bgcolor="grey" width="10%" align="center"><img src="./black ball.png" alt=""></td>
                                 <td bgcolor="grey" width="10%" align="center"><img src="./black ball.png" alt=""></td>
                              </tr>
                            </table>
                            <br>
                            <br>
                            <p>The black marblescan only to the right, and the white marbles can only move to the left (no backing up). At each move. a <br>
                               marble can either:</p>
                               <br>
                               <ul>
                                 <li>Move one space ahead, if that space is clear, or </li>
                                 <br>
                                 <li>Jump ahead over exactly one marble of the opposite color, if the space just beyond that marble is clear.</li>
                               </ul>
                               <br>
                               <br>
                               <p>For example, you could make the following sequence of moves:</p>
                               <br>
                               <table border="1" align="center" >
                                 <tr >
                          <b align="center"> <br>
                           starting position:</b>   <td bgcolor="grey" align="center"><img src="./black ball.png" alt=""></td>
                                                                 <td bgcolor="grey" align="center" ><img src="./black ball.png" alt=""></td>
                                                                 <td bgcolor="grey" align="center">&nbsp;</td>
                                                                 <td bgcolor="grey" align="center" ><img src="./white ball.png" alt=""></td>
                                                                 <td bgcolor="grey" align="center" ><img src="././white ball.png" alt=""></td>
                                 </tr> 
                                 
                                 <tr > <br>
                                     <b>Black moves ahead</b>
                                                                <td bgcolor="grey" align="center"><img src="./black ball.png" alt=""></td>
                                                                <td bgcolor="grey" align="center">&nbsp;</td>
                                                                <td bgcolor="grey" align="center"><img src="./black ball.png" alt=""></td>
                                                                <td bgcolor="grey" align="center"><img src="./white ball.png" alt=""></td>
                                                                <td bgcolor="grey" align="center"><img src="././white ball.png" alt=""></td>
                                </tr>

                                <tr> <br>
                                  <b> white jump: </b>
                                 <td bgcolor="grey" align="center"><img src="./black ball.png" alt=""></td><br>
                                 <td bgcolor="grey" align="center"><img src="./white ball.png" alt=""></td><br>
                                 <td bgcolor="grey" align="center"><img src="./black ball.png" alt=""></td>
                                 <td bgcolor="grey" align="center">&nbsp;</td>
                                 <td bgcolor="grey" align="center"><img src="././white ball.png" alt=""></td>
 </tr> 
  <tr> <br>
   <b>Black moves ahead</b>
   <td bgcolor="grey" align="center"><img src="./black ball.png" alt=""></td>
   <td bgcolor="grey" align="center"><img src="./white ball.png" alt=""></td>
   <td bgcolor="grey" align="center">&nbsp;</td>
   <td bgcolor="grey" align="center"><img src="./black ball.png" alt=""></td>
   <td bgcolor="grey" align="center"><img src="././white ball.png" alt=""></td>
</tr> 
 <tr><br>
   <b>Black jump:b>
   <td bgcolor="grey" align="center">&nbsp;</td>
   <td bgcolor="grey" align="center"><img src="./white ball.png" alt=""></td>
   <td bgcolor="grey" align="center"><img src="./black ball.png" alt=""></td>
   <td bgcolor="grey" align="center"><img src="./black ball.png" alt=""></td>
   <td bgcolor="grey" align="center"><img src="././white ball.png" alt=""></td>
</tr>

<tr> <br>
   <b>white moves ahead</b>
   <td bgcolor="grey" align="center">&nbsp;</td>
   <td bgcolor="grey" align="center"><img src="./white ball.png" alt=""></td>
   <td bgcolor="grey" align="center"><img src="./black ball.png" alt=""></td>
   <td bgcolor="grey" align="center"><img src="./black ball.png" alt=""></td>
   <td bgcolor="grey" align="center"><img src="././white ball.png" alt=""></td>
   
</tr>
<b> stuck:</b> </table>
<br>
<p>the backtraacking method is named and return a boolean. in solvable we shall need to check whether we are at a leaf, <br>
   which in this case means a position from which no futher moves are possible. This isn't check.</p>
   <br><br>
   <p>Now to the program. The main program will initialize the board, and call a recusive backtraacking routine to attempt to solve the <br>
   print out the bad news.</p>
   <br><br>
    <p>The backtraacking method is named board position, and these new board position are the children of the current board <br>
      positionhence to find the chidren of a (that is of a board position), we need only find the possible moves from that node. <br>
      remember that it is also higly desirable to find an ordering on these possible moves.
    </p>
    <br><br>
    <p>Here it is time to stop and take through. To make progress, we must analyze the game to some exent. probably a number of <br>
   approach would work, and what follows is based on the way i worked it out if you were to program this Puzzle,you might find <br>
   a diffrent but equally valid approach.</p>
   <br><br>
   <p>first, notice that if a marble has a move, that move is uniqe: if it can move ahead one square, then it cannot jump. if it can jump, <br>
   it cannot move ahead one square. This suggests that, to find the possible moves we assign number  to the marbles, and <br>
   having a table to keep track of where each marble is, or else somehow "marking" esch marble with its number and searching the <br>
   board each time to find the marble we want. Neither alternative is very attrative.</p>
   <br><br>
   <p><b>now w have a simpler ordering of moves to use in uor program. just chech, in  ordre the 2n+1 spaces of the board. for each <br>
   space, either zero or one moves possible. with this understanding, we can write a boolean method canmove(int[]board, int <br>
position) which determines whether a move is possible from the given position.</b></p>
<br><br>
<ul>
   <li> if the positionis empty, no move is possible;</li>
   <br>
   <li>if the position contai]s a black marble, the method check for a move or jump to the right;</li>
   <br>
   <li>if the position contains a white marble, check for a move or jump to the lest ; </li>
</ul>
<br>
 <p>We wite another method <b>int[]make Move(int[] oldBoard, int position)</b> that will take a position, make a move frome <br>
   that position, and  return as its value a new board (we could write this somewhat more effciently by changing the old board,<br>
   rather than creating a new one but here we are more concerned eith simplicity.) in tachniacal jargon, makeMove is "applicative" <br>
   rather than "mutative."</p><br>
   <br>
   <p> along with <b>canMove,</b> we are using methods <b>PuzzleSolved and printBoard</b> with meanigs that <br>
   should be obvious.</p> 
   <br>
   <br>
   <font color="blue">
      <pre>
         boolean solvable(int[] board) {
            if (PuzzleSolved(board)) {
               return true;
            }
         }
         for (int position = 0; position < BOARD_SIZE; position++) {
            if (canMove(board, position)) {
               int[] newboard = makemove(board,position);
               if (solvable(newBoard)) {
                  printBoard(newBoard);
                  return true;
               }
            }
         }
         return false; 
      }
      </pre>
   </font>
   <p>Along with canMove and makeMove, we are using methods PuzzleSolved and printBoard with meanigs that should be obvious<br>
      here is some output from the program:</p>
      <br>
      <br>
      <b>16. WHITE WHITE WHITE______ BLACK BLACK BLACK</b> <br>
      <b>15. WHITE WHITE WHITE BLACK _____ BLACK BLACK</b> <br>
      <b>14. WHITE WHITE _____ BLACK WHITE BLACK BLACK</b> <br>
      <b>13. WHITE _____ WHITE BLACK WHITE BLACK BLACK</b> <br>
      <b>12. WHITE BLACK WHITE _____ WHITE BLACK BLACK</b> <br>
      <b>11. WHITE BLACK WHITE BLACK WHITE _____ BLACK</b> <br>
      <b>10. WHITE BLACK WHITE BLACK WHITE BLACK _____</b> <br>
      <b>9. WHITE BLACK WHITE BLACK _____ BLACK WHITE </b> <br>
      <b>8. WHITE BLACK _____ BLACK WHITE BLACK WHITE</b> <br>
      <b>7. _____ BLACK WHITE BLACK WHITE BLACK WHITE</b> <br>
      <b>6. BLACK _____ WHITE BLACK WHITE BLACK WHITE</b> <br>
      <b>5. BLACK BLACK WHITE _____ WHITE BLACK WHITE</b> <br>
      <b>4. BLACK BLACK WHITE BLACK WHITE _____ WHITE</b> <br>
      <b>3. BLACK BLACK WHITE BLACK _____ WHITE WHITE </b> <br>
      <b>2. BLACK BLACK _____ BLACK WHITE WHITE WHITE</b> <br>
      <b>1. BLACK BLACK BLACK _____ WHITE WHITE WHITE</b> 
      <br>
      <br>
      <fieldset>
         <p>notice that the solutin is given in reverse ordre: BLACK start out on the left and WHITE on the right, as in the last <br>
            line. i"ve added line numbers to the achual output in order to emphsize this point. backtraacking always produces its <br>
         results (sequence of choices) ibn reverse order; it is up to you, the programmer to reverse the result again to get <br>
      them  in the correct order.</p>
      </fieldset>
                               
             </body>

            </html>